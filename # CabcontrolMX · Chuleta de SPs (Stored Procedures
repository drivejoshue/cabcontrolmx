{
  "brand": "Taxio",
  "slogan": "tu central en un tap",
  "colors": {
    "primary": "#FFC400",
    "text": "#222222",
    "bg": "#FFFFFF",
    "muted": "#6B7280",
    "accent": "#00B3B3"
  },
  "logo": {
    "wordmark_o_is_pin": true,
    "radius_app_icon": 0.203
  },
  "typography": { "heading": "Inter-Black", "body": "Inter" }
}
App IDs / dominios (elige y verifica)
Dominio: taxio.mx, taxioapp.mx, taxioops.com (verificar disponibilidad)

Android package: mx.taxio.central (admin), mx.taxio.driver (conductor)

iOS bundle: mx.taxio.central, mx.taxio.driver

UI rápido (splash/login)
Splash: fondo #FFC400, monograma centrado, “Taxio” abajo en negro.

Login: botón primario #222222 con texto blanco; secundarios en #00B3B3.

Radio/WhatsApp (cómo suena)
“Despáchalo por Taxio.”

“¿Confirmas viaje de Taxio?”

“Taxio: unidad 23 asignada.”

Siguientes pasos
Renombrar repos/envs: cabcontrolmx → taxio (Docker, .env, Postman, bundle IDs).

Generar icon set (iOS 1024px, Android mipmap, favicon).

Insertar paleta/tokens en tu tema (Tailwind/WinForms/MAUI).

¿Quieres que te entregue los PNGs/ICOs ya exportados y un splash listo para Android/iOS? Puedo prepararlos y te paso los archivos.







Tú dijiste:
debriamos ur el tipico fondo amarillo de cuadron negfros ?  o que me sugieres para ir a modernidad y distincion ? 


ChatGPT Plus
Buenísima pregunta. El “amarillo + cuadros negros” es reconocible, pero hoy se ve retro y a veces “genérico taxi”. Si quieres modernidad y distinción, te propongo tres rutas visuales (todas mantienen la lectura “taxi” sin caer en el checkered clásico).

1) Moderno-urbano (mi favorita para Taxio)
Paleta: Amarillo más sofisticado + negro carbón + acento turquesa.

Yellow: #FFC400 (o más sobrio #F5C518)

Carbón: #1F2937

Blanco: #FFFFFF

Acento teal: #00B3B3

Reemplazo de cuadros: usa líneas diagonales sutiles o patrón de “grid” suave al 4–6% de opacidad en fondos, no el “checker” pesado.

Tipografía: Sans geométrica (Inter/Manrope) pesada en títulos.

Icono: la “o” como pin + punto central; animación micro (latido/scale 1.05 al asignar viaje).

Ventaja: se siente taxi, pero corporativo/tech. Ideal para vender a centrales.

2) Pro tech (oscuro con acento)
Paleta: Fondo oscuro + acentos vibrantes.

Graphite: #0F172A

Gray UI: #334155

Acento Lemon: #FFD34D

Acento Mint: #19D3B3

Uso del amarillo: solo en CTAs y badges (no de fondo).

Ventaja: se ve premium, destaca dashboards y mapas nocturnos.

Riesgo: si abusas de oscuro, puede “apagar” la marca en calle.

3) Urbano minimal (sin amarillo dominante)
Paleta: Blanco/negro + acento único (mostaza o lima).

Black: #111111

White: #FFFFFF

Mostaza: #E0B100 (o Lima #B7F000)

Firma visual: barra lateral o subrayado en amarillo en componentes clave (botones, tabs).

Ventaja: distinción y limpieza; fácil de extender a módulos.

¿Y los cuadros negros?
Úsalos solo como guiño:

En microdetalles: una franja de 8–12px con patrón de cuadros muy tenue (10–15% opacidad) en headers de ticket, o en un loader.

En stickers físicos: calcomanía mínima para las bases (no en toda la app).

Nunca como background completo ni en el botón primario.

Componentes clave (ejemplos rápidos)
Botón primario: fondo #1F2937, texto blanco, borde inferior de 2px en #FFC400.

Badge “ASIGNADO”: pill #FFC400 con texto #1F2937.

Mapa en app: tema dark con pins amarillo #FFC400; el pin de “tu taxi” usa anillo teal #00B3B3.

Card de unidad: foto/placa a la izquierda, nombre conductor, rating; CTA “Despachar” en negro con hover a #111.

Accesibilidad y legibilidad
Contraste mínimo 4.5:1 en texto; Amarillo sobre negro (sí), amarillo sobre blanco (no).

Tamaños de toque ≥ 44px; iconos simples (sin contornos finos sobre amarillo).

Qué haría para Taxio (decisión)
Me iría por Moderno-urbano: mantiene identidad taxi con un amarillo elegante, sin el cliché de cuadros.

Dejaría un guiño de checker ultra sutil en tickets o en el splash (línea corta diagonal), y listo.

Si te late, te paso un mini kit (botones, badges, navbar, tarjeta de viaje) en tus colores para que lo pegues en tu Admin/Laravel/MAUI. ¿Lo quieres en Tailwind (web) y XAML (MAUI) con variables/tokens?














# CabcontrolMX · Chuleta de SPs (Stored Procedures)
**Última actualización:** 2025-10-09

Esta chuleta resume los procedimientos almacenados que definimos y cómo usarlos desde tu backend, panel de dispatch y apps (MAUI Driver/Passenger). Incluye parámetros, precondiciones, efectos colaterales, mensajes de error y ejemplos de uso.

---

## Convenciones del esquema (esperadas)
- `rides.status` enum: `requested`, `offered`, `accepted`, `en_route`, `arrived`, `on_board`, `finished`, `canceled`
- `ride_offers.status` enum: `offered`, `accepted`, `rejected`, `expired`, `canceled`, `released`
- `ride_offers.response` enum: `accepted`, `rejected`, `expired`, `canceled`, `released`
- `driver_shifts.status`: `abierto` (abierto) / `cerrado`
- Normalizamos `canceled_by` a: `dispatch | driver | passenger | system` (fallback a `dispatch`)

> Asegúrate de que los ENUMs de `ride_offers` estén ampliados así para evitar warnings `#1265 datos truncados`.

---

## Lista de SPs

### 1) `sp_nearby_drivers(p_tenant_id, p_origin_lat, p_origin_lng, p_radius_km)`
**Objetivo:** listar candidatos por radio (rápido) usando Haversine y `driver_shifts='abierto'`  
**Precondiciones:** driver `idle` con `last_lat/lng` y shift `abierto`.  
**Retorno:** *SELECT de filas* (este SP sí devuelve lista—it’s a finder).  
**SQL ejemplo:**
```sql
CALL sp_nearby_drivers(1, 19.173773, -96.134224, 5.0);
```

---

### 2) `sp_create_offer_v2(p_tenant_id, p_ride_id, p_driver_id, p_expires_sec)` (silencioso)
**Objetivo:** crear una oferta **viva** a un driver.  
**Precondiciones:**
- Ride del tenant en `requested|offered` y **sin driver**.
- Driver del tenant en `idle` con coords y shift `abierto` (toma `vehicle_id` del shift).
**Efectos:**
- Inserta en `ride_offers` con `status='offered'`, `expires_at=NOW()+expires`.
- Si ride estaba `requested` → pasa a `offered`.
**Errores comunes:** “Ride no ofertable…”, “Driver no está idle”, “Driver sin shift abierto/vehículo”.
**Uso:**
```sql
CALL sp_create_offer_v2(1, @ride_id, 1, 45);
SELECT LAST_INSERT_ID();
```

---

### 3) `sp_accept_offer_v3(p_offer_id)` (silencioso)
**Objetivo:** aceptar una oferta y **asignar** el ride.  
**Precondiciones:** oferta `offered` y no expirada; ride en `requested|offered` sin driver.  
**Efectos:** `rides.status='accepted'`, set `driver_id`, `vehicle_id`; oferta → `accepted`; otras ofertas → `rejected`.  
**Errores:** “Oferta inexistente”, “Oferta expirada”, “Ride no ofertable o ya asignado”.  
**Uso:**
```sql
CALL sp_accept_offer_v3(@offer_id);
```

---

### 4) `sp_reject_offer_v2(p_offer_id)` (silencioso)
**Objetivo:** rechazar una oferta (conductor o backend).  
**Precondiciones:** oferta `offered` y no expirada.  
**Efectos:** oferta → `rejected`.  
**Uso:** `CALL sp_reject_offer_v2(123);`

---

### 5) `sp_expire_offers_v2(p_tenant_id, p_ride_id)` (silencioso)
**Objetivo:** marcar expiradas ofertas `offered` con `expires_at < NOW()` de un ride.  
**Uso:** `CALL sp_expire_offers_v2(1, @ride_id);`

---

### 6) `sp_offer_wave_v1(p_tenant_id, p_ride_id, p_radius_km, p_limit_n, p_expires_sec)` (silencioso)
**Objetivo:** disparar **ola** por radio a top N drivers cercanos.  
**Filtro:** `idle` + `shift='abierto'` dentro de `p_radius_km` ordenados por distancia.  
**Efecto:** Llama internamente `sp_create_offer_v2` para cada driver (evita duplicados vivos).

---

### 7) `sp_offer_wave_v2(p_tenant_id, p_ride_id, p_driver_ids_csv, p_expires_sec)` (silencioso)
**Objetivo:** disparar **ola** a una **lista explícita** de drivers `"1,5,9"`.  
**Efectos/Validaciones:** iguales a v1; además evita dups para ese ride/driver.

---

### 8) `sp_release_ride_v1(p_tenant_id, p_ride_id)` (silencioso)
**Objetivo:** **liberar** un ride asignado (no lo cancela).  
**Precondiciones:** ride en `accepted` con driver.  
**Efectos:** quita `driver_id/vehicle_id`, `status='requested'`; oferta aceptada → `released`; ofertas `offered` → `expired`.  
**Errores:** “Ride no liberable…”, “No se pudo liberar (carrera de estado)”.

---

### 9) `sp_cancel_ride_v2(p_tenant_id, p_ride_id, p_canceled_by, p_reason)` (silencioso)
**Objetivo:** **cancelar** ride desde dispatch/driver/passenger/system con auditoría.  
**Normalización:** `p_canceled_by` se mapea a `dispatch|driver|passenger|system` (fallback `dispatch`).  
**Efectos:** `rides.status='canceled'`, set `canceled_at/by/reason`; ofertas `offered|accepted` → `canceled`.

---

### 10) `sp_complete_ride_v1(p_tenant_id, p_ride_id, p_distance_m, p_duration_s)` (silencioso)
**Objetivo:** **finalizar** ride (MAUI driver/backend).  
**Precondiciones:** ride del tenant, con driver y en `accepted`.  
**Efectos:** opcionalmente actualiza `distance_m/duration_s`; `status='finished'`, `finished_at=NOW()`.  
**Uso:** `CALL sp_complete_ride_v1(1, @ride_id, 5050, 880);`

---

## Troubleshooting
- **Datos truncados en `ride_offers.response/status`**: amplía los `ENUM` como arriba.
- **commands out of sync**: usa SP **silenciosos** (ya lo hicimos) o ejecuta bloques completos en una pestaña.
- **@vars NULL en phpMyAdmin**: ejecuta **todo el bloque** en una sola corrida; usa `SELECT LAST_INSERT_ID()` tras `CALL` que insertan.

---

## Flujos recomendados
**Oferta → aceptación**  
1) `CALL sp_offer_wave_v1` o `sp_offer_wave_v2`  
2) `SELECT LAST_INSERT_ID()` → `@offer_id`  
3) `CALL sp_accept_offer_v3(@offer_id)`

**Autodespacho por olas**  
- OLA: `sp_offer_wave_v1` → esperar `N` segundos → `sp_expire_offers_v2` → repetir.  
- Si ninguna aceptación tras K olas: alertar a operador (fallback).

**Liberación**  
- `CALL sp_release_ride_v1` → vuelve a `requested` → reofertar ola o asignar directo.

**Cancelación con auditoría**  
- `CALL sp_cancel_ride_v2(tenant, ride, who, reason)`

**Finalización (MAUI)**  
- `CALL sp_complete_ride_v1(tenant, ride, distance, duration)`

---

## SQL de verificación útil
```sql
-- Ofertas por ride (estado resumido)
SELECT id, driver_id, status, response, expires_at
FROM ride_offers
WHERE ride_id = @ride_id
ORDER BY id DESC;

-- Ride + identificadores visuales de vehículo
SELECT r.id AS ride_id, r.status, r.driver_id,
       v.id AS vehicle_id, v.economico, v.plate
FROM rides r
LEFT JOIN vehicles v ON v.id = r.vehicle_id
WHERE r.id = @ride_id;
```



Tarifas (config por tenant, sin centavos)
Campos de configuración (en tenant_fare_policies)

base_fee (DECIMAL): cargo base.

per_km (DECIMAL): cargo por kilómetro.

per_min (DECIMAL): cargo por minuto.

min_total (DECIMAL): mínimo a cobrar.

night_multiplier (DECIMAL): multiplicador nocturno (ej. 1.25).

night_start_hour (TINYINT, default 22): hora de inicio nocturna (0–23).

night_end_hour (TINYINT, default 6): hora de fin nocturna (0–23). La ventana es [start..23] ∪ [0..end-1].

round_mode (ENUM decimals|step, default step).

round_decimals (TINYINT, si round_mode=decimals).

round_step (DECIMAL, default 1.00): paso de redondeo (sin centavos ⇒ 1.00).

Con estos campos cada tenant define ventana nocturna y redondeo. Defaults: noche 22–6 y redondeo por paso 1.00 (montos enteros: 95.00, 96.00, …).

Función de apoyo
round_to_step(p_amount, p_step) → DECIMAL(12,2)

Objetivo: redondear a un paso (sin centavos si step=1.00).

Ejemplos:
round_to_step(95.49, 1.00) = 95.00
round_to_step(95.50, 1.00) = 96.00
round_to_step(95.25, 0.50) = 95.50

SPs de tarifa
1) sp_set_route_v1(p_tenant_id, p_ride_id, p_distance_m, p_duration_s, p_polyline) (silencioso)

Objetivo: guardar distancia/tiempo/polyline sugeridos (Google/OSRM) en el ride.
Precondiciones: ride pertenece al tenant.

Efectos:

Actualiza rides.distance_m, rides.duration_s, rides.route_polyline.

Uso:

CALL sp_set_route_v1(1, @ride_id, 4200, 780, 'ENCODED_POLYLINE');

2) sp_quote_ride_v2(p_tenant_id, p_ride_id, p_when_ts) (silencioso)

Objetivo: calcular y persistir la tarifa sugerida del ride según la política vigente del tenant.

Reglas:

Si el ride ya tiene distance_m/duration_s → calcula completo:
subtotal = base_fee + km*per_km + min*per_min → subtotal = max(subtotal, min_total)
Aplica ventana nocturna configurable → subtotal * night_multiplier cuando corresponde.
Aplica redondeo:

round_mode=step ⇒ round_to_step(total, round_step) (default, enteros).

round_mode=decimals ⇒ ROUND(total, round_decimals).

Si el ride no tiene distancia/tiempo (sin destino) → cotiza base/min_total, marca partial=true en el snapshot (luego re-cotizas cuando haya destino).

Persiste:

rides.quoted_amount

rides.fare_snapshot (JSON con política, inputs, cálculo, partial y resultado).

Precondiciones:

Debe existir una política activa (toma la fila más reciente del tenant).

Uso:

-- Cotiza ahora (usa NOW() para ventana nocturna)
CALL sp_quote_ride_v2(1, @ride_id, NULL);

-- Cotiza a una hora específica (p. ej. simulación noche)
CALL sp_quote_ride_v2(1, @ride_id, '2025-10-09 22:30:00');


Re-cotizar cuando se defina el destino:

-- 1) Guardar métricas de ruta
CALL sp_set_route_v1(1, @ride_id, 4200, 780, 'ENCODED_POLYLINE');

-- 2) Recalcular tarifa final (quita partial=true)
CALL sp_quote_ride_v2(1, @ride_id, NULL);


Lectura recomendada (para UI):

SELECT id, distance_m, duration_s, quoted_amount FROM rides WHERE id=@ride_id;
SELECT JSON_PRETTY(fare_snapshot) FROM rides WHERE id=@ride_id;

Flujos recomendados (resumen)

Oferta → aceptación

CALL sp_offer_wave_v1 o sp_offer_wave_v2

SELECT LAST_INSERT_ID() → @offer_id

CALL sp_accept_offer_v3(@offer_id)

Autodespacho por olas

OLA: sp_offer_wave_v1 → esperar N s → sp_expire_offers_v2 → repetir.

Si nadie acepta tras K olas: alertar a operador (fallback).

Liberación

CALL sp_release_ride_v1 → vuelve a requested → reofertar ola o asignar directo.

Cancelación con auditoría

CALL sp_cancel_ride_v2(tenant, ride, who, reason)
(normaliza canceled_by a dispatch|driver|passenger|system; fallback dispatch)

Finalización (MAUI)

CALL sp_complete_ride_v1(tenant, ride, distance, duration) → status='finished'.

Tarifa

Sin destino: sp_quote_ride_v2 cotiza base/min_total (partial=true).

Con destino: sp_set_route_v1 → sp_quote_ride_v2 (tarifa final, redondeo por paso).

SQL de verificación útil
-- Ofertas por ride (estado resumido)
SELECT id, driver_id, status, response, expires_at
FROM ride_offers
WHERE ride_id = @ride_id
ORDER BY id DESC;

-- Ride + identificadores visuales de vehículo
SELECT r.id AS ride_id, r.status, r.driver_id,
       v.id AS vehicle_id, v.economico, v.plate
FROM rides r
LEFT JOIN vehicles v ON v.id = r.vehicle_id
WHERE r.id = @ride_id;

-- Tarifa y snapshot
SELECT id, distance_m, duration_s, quoted_amount FROM rides WHERE id=@ride_id;
SELECT JSON_PRETTY(fare_snapshot) FROM rides WHERE id=@ride_id;


1) Alta de ride + ruta + tarifa
-- Crear ride
INSERT INTO rides (tenant_id, passenger_id, status, payment_method,
                   origin_lat, origin_lng, dest_lat, dest_lng, requested_channel, created_at)
VALUES (1, 2, 'requested', 'cash',
        19.173773, -96.134224, 19.1805, -96.1429, 'dispatch', NOW());
SET @ride_id := LAST_INSERT_ID();

-- Persistir ruta sugerida (cuando ya la tengas)
CALL sp_set_route_v1(1, @ride_id, 5050, 880, 'ENCODED_POLYLINE');

-- Cotizar (sin centavos, redondeo cerrado según políticas)
CALL sp_quote_ride_v1(1, @ride_id, NOW());

-- Ver
SELECT distance_m, duration_s, quoted_amount, fare_snapshot
FROM rides WHERE id=@ride_id;

2) Olas con prioridad de base y aceptación (cola avanza)
-- (Opcional) formar conductores en Base Centro
SET @stand_id := (SELECT id FROM taxi_stands WHERE tenant_id=1 AND nombre='Base Centro' LIMIT 1);
CALL sp_queue_join_stand_v1(1, @stand_id, 1);
CALL sp_queue_join_stand_v1(1, @stand_id, 2);

-- OLA (lee radios de dispatch_settings columnas; prioriza cola)
CALL sp_offer_wave_base_prio_v2(1, @ride_id, 3, 45);
SELECT @offer_id := LAST_INSERT_ID();

-- Aceptar (asigna ride, bitácora extendida con stand, avanza cola)
CALL sp_accept_offer_v3(@offer_id);

-- Ver ofertas e historial
SELECT id, driver_id, status FROM ride_offers WHERE ride_id=@ride_id ORDER BY id;
SELECT prev_status, new_status, meta FROM ride_status_history WHERE ride_id=@ride_id ORDER BY id;

3) Reofertar, liberar, cancelar, finalizar
-- Liberar (regresa a requested y expira ofertas vivas)
CALL sp_release_ride_v1(1, @ride_id);

-- Reofertar ola
CALL sp_offer_wave_base_prio_v2(1, @ride_id, 3, 45);

-- Cancelar con auditoría
CALL sp_cancel_ride_v2(1, @ride_id, 'dispatch', 'Cliente no llegó');

-- Finalizar (desde MAUI) con métricas reales
CALL sp_complete_ride_v1(1, @ride_id, 5000, 900);

4) Autodespacho (NO activado aún)

Tienes el tick listo: sp_autodispatch_tick_v2(tenant_id).

Cuando quieras activarlo como EVENT por minuto:

SET GLOBAL event_scheduler = ON;
DROP EVENT IF EXISTS ev_autodispatch_tick_t1;
CREATE EVENT ev_autodispatch_tick_t1
ON SCHEDULE EVERY 1 MINUTE
DO CALL sp_autodispatch_tick_v2(1);

5) Notas clave de integridad

Anti “doble accepted”: trigger/guard activo en ride_offers (insert/update).

No duplicar “offered” al mismo driver/ride: sp_create_offer_v2 renueva expires_at si ya existe una offered viva (no crea otra).

Bitácora extendida en ride_status_history:

accepted incluye offer_id, driver_id, vehicle_id, economico, plate, driver_last_lat/lng, y si aplica: stand_id_on_accept, stand_name_on_accept, stand_dist_km.

Radios por tenant: dispatch_settings.stand_radius_km (bases) y auto_dispatch_radius_km (calle).

Colecciones Postman (resumen de endpoints)
Dispatch & Passenger

POST /api/rides – crear ride (crea ruta+tarifa internamente o después con endpoints dedicados).

POST /api/rides/:ride_id/route – sp_set_route_v1.

POST /api/rides/:ride_id/quote – sp_quote_ride_v1.

GET /api/dispatch/nearby-drivers?tenant_id&lat&lng&km – sp_nearby_drivers.

POST /api/dispatch/offer-wave – sp_offer_wave_base_prio_v2.

POST /api/offers/:offer_id/accept – sp_accept_offer_v3.

POST /api/rides/:ride_id/release – sp_release_ride_v1.

POST /api/rides/:ride_id/cancel – sp_cancel_ride_v2.

POST /api/rides/:ride_id/complete – sp_complete_ride_v1.

POST /api/queue/join / /api/queue/leave – cola de bases.

POST /api/dispatch/tick – sp_autodispatch_tick_v2 (manual).

Driver (MAUI)

POST /api/driver/shifts/open / /api/driver/shifts/close.

POST /api/driver/location – ping para driver_locations + drivers.last_lat/lng.

GET /api/driver/offers?tenant_id&driver_id – ofertas vivas.

POST /api/offers/:offer_id/accept – aceptar.

POST /api/offers/:offer_id/reject – rechazar.

POST /api/queue/join-by-name – helper que resuelve stand por nombre.

POST /api/rides/:ride_id/complete – finalizar.

Las colecciones incluyen body de ejemplo y paths con :ride_id, :offer_id, etc. Cambia {{baseUrl}} en Postman a tu host real.


------ prueba sql  


USE cabcontrolmx;

-- Limpieza mínima
SET FOREIGN_KEY_CHECKS=0;
TRUNCATE TABLE ride_status_history;
TRUNCATE TABLE ride_offers;
TRUNCATE TABLE rides;
SET FOREIGN_KEY_CHECKS=1;

-- =============================
-- Vehículos (usa 'active', NO 'status')
-- =============================
INSERT INTO vehicles (tenant_id, economico, plate, active, created_at)
VALUES (1, 'TX-001', 'ABC-001', 1, NOW())
ON DUPLICATE KEY UPDATE active=1;

INSERT INTO vehicles (tenant_id, economico, plate, active, created_at)
VALUES (1, 'TX-002', 'ABC-002', 1, NOW())
ON DUPLICATE KEY UPDATE active=1;

-- tomar 2 vehicle_id activos
SELECT @veh1 := id
FROM vehicles
WHERE tenant_id=1 AND active=1
ORDER BY id DESC
LIMIT 1;

SELECT @veh2 := id
FROM vehicles
WHERE tenant_id=1 AND active=1
ORDER BY id DESC
LIMIT 1 OFFSET 1;

SET @veh2 := COALESCE(@veh2, @veh1);

-- =============================
-- Conductores (drivers.status sí existe)
-- =============================
INSERT INTO drivers (id, tenant_id, name, status, last_lat, last_lng, created_at)
VALUES (1, 1, 'Driver 1', 'idle', 19.1730, -96.1335, NOW())
ON DUPLICATE KEY UPDATE
  name=VALUES(name), status='idle', last_lat=VALUES(last_lat), last_lng=VALUES(last_lng);

INSERT INTO drivers (id, tenant_id, name, status, last_lat, last_lng, created_at)
VALUES (2, 1, 'Driver 2', 'idle', 19.1740, -96.1340, NOW())
ON DUPLICATE KEY UPDATE
  name=VALUES(name), status='idle', last_lat=VALUES(last_lat), last_lng=VALUES(last_lng);

-- =============================
-- Shifts (driver_shifts.status sí existe)
-- =============================
UPDATE driver_shifts
SET status='cerrado', ended_at=NOW()
WHERE tenant_id=1 AND driver_id IN (1,2) AND status='abierto';

INSERT INTO driver_shifts (tenant_id, driver_id, vehicle_id, started_at, status, created_at)
VALUES
(1, 1, @veh1, NOW(), 'abierto', NOW()),
(1, 2, @veh2, NOW(), 'abierto', NOW());

-- Ver
SELECT id, tenant_id, driver_id, status, vehicle_id, started_at
FROM driver_shifts
WHERE tenant_id=1 AND driver_id IN (1,2)
ORDER BY id DESC;

-- =============================
-- RIDE #1: oferta → aceptar → liberar → reoferta → aceptar → finalizar
-- =============================
INSERT INTO rides
(tenant_id, passenger_id, status, payment_method,
 origin_lat, origin_lng, dest_lat, dest_lng, requested_channel, created_at)
VALUES
(1, 2, 'requested', 'cash',
 19.173773, -96.134224, 19.180500, -96.142900, 'dispatch', NOW());
SET @ride_id := LAST_INSERT_ID();

CALL sp_create_offer_v2(1, @ride_id, 1, 60);
SELECT @offer_1 := LAST_INSERT_ID();

CALL sp_create_offer_v2(1, @ride_id, 2, 60);
SELECT @offer_2 := LAST_INSERT_ID();

CALL sp_accept_offer_v3(@offer_1);

-- si quieres validar el guard, ejecuta esta línea por separado para ver el error:
-- CALL sp_accept_offer_v3(@offer_2);

CALL sp_release_ride_v1(1, @ride_id);

CALL sp_offer_wave_v1(1, @ride_id, 5.0, 3, 45);
SELECT @offer_new := LAST_INSERT_ID();

CALL sp_accept_offer_v3(@offer_new);

CALL sp_complete_ride_v1(1, @ride_id, 5000, 900);

SELECT * FROM ride_status_history WHERE ride_id=@ride_id ORDER BY id;

-- =============================
-- RIDE #2: oferta → aceptar → cancelar
-- =============================
INSERT INTO rides
(tenant_id, passenger_id, status, payment_method,
 origin_lat, origin_lng, dest_lat, dest_lng, requested_channel, created_at)
VALUES
(1, 2, 'requested', 'cash',
 19.180000, -96.140000, 19.185000, -96.150000, 'dispatch', NOW());
SET @ride2 := LAST_INSERT_ID();

CALL sp_create_offer_v2(1, @ride2, 1, 45);
SELECT @offer2 := LAST_INSERT_ID();

CALL sp_accept_offer_v3(@offer2);

CALL sp_cancel_ride_v2(1, @ride2, 'dispatch', 'Prueba cancelación');

SELECT * FROM ride_status_history WHERE ride_id=@ride2 ORDER BY id;

-- Resúmenes
SELECT id, status, driver_id, vehicle_id, finished_at, canceled_at, canceled_by, cancel_reason
FROM rides
WHERE id IN (@ride_id, @ride2)
ORDER BY id;

SELECT id, ride_id, driver_id, status, response, expires_at, responded_at
FROM ride_offers
WHERE ride_id IN (@ride_id, @ride2)
ORDER BY ride_id, id;





-------- pruebcon cola de bases   

USE cabcontrolmx;

-- 1) Asegura el sector (requerido por la FK en taxi_stands.sector_id)
INSERT INTO sectores (tenant_id, nombre, activo, created_at)
VALUES (1, 'Centro', 1, NOW())
ON DUPLICATE KEY UPDATE id=LAST_INSERT_ID(id);

SELECT @sector_id := id
FROM sectores
WHERE tenant_id=1 AND nombre='Centro'
ORDER BY id DESC
LIMIT 1;

-- 2) Asegura la base "Base Centro" ligada al sector
-- Si tu tabla exige 'codigo' NOT NULL, descomenta y usa 'BCENTRO'
INSERT INTO taxi_stands (tenant_id, sector_id, nombre, /*codigo,*/ latitud, longitud, activo, created_at)
VALUES (1, @sector_id, 'Base Centro', /*'BCENTRO',*/ 19.173900, -96.134000, 1, NOW())
ON DUPLICATE KEY UPDATE activo=1;

SELECT @stand_id := id
FROM taxi_stands
WHERE tenant_id=1 AND nombre='Base Centro'
ORDER BY id DESC
LIMIT 1;

-- 3) Asegura que @stand_id no sea NULL (si lo es, algo falló en FK sector)
SELECT @stand_id AS stand_id_comprobacion;

-- 4) Opcional: limpia la cola de esa base para una prueba clara
DELETE FROM taxi_stand_queue WHERE tenant_id=1 AND stand_id=@stand_id;

-- 5) Asegura drivers 1 y 2 'idle' + shift abierto con vehicle_id
-- (ajusta si usas otros IDs)
UPDATE drivers SET status='idle', last_lat=19.1730, last_lng=-96.1335 WHERE tenant_id=1 AND id=1;
UPDATE drivers SET status='idle', last_lat=19.1740, last_lng=-96.1340 WHERE tenant_id=1 AND id=2;

-- toma vehículos activos existentes (usa alguno)
SELECT @veh1 := id FROM vehicles WHERE tenant_id=1 AND active=1 ORDER BY id DESC LIMIT 1;
SELECT @veh2 := id FROM vehicles WHERE tenant_id=1 AND active=1 ORDER BY id DESC LIMIT 1 OFFSET 1;
SET @veh2 := COALESCE(@veh2, @veh1);

-- cierra y abre shifts
UPDATE driver_shifts SET status='cerrado', ended_at=NOW()
WHERE tenant_id=1 AND driver_id IN (1,2) AND status='abierto';

INSERT INTO driver_shifts (tenant_id, driver_id, vehicle_id, started_at, status, created_at)
VALUES (1,1,@veh1,NOW(),'abierto',NOW()), (1,2,@veh2,NOW(),'abierto',NOW());

-- 6) Entra a la cola (posiciones 1 y 2)
CALL sp_queue_join_stand_v1(1, @stand_id, 1);
CALL sp_queue_join_stand_v1(1, @stand_id, 2);

-- 7) Ahora sí: SELECT sin riesgo de stand_id NULL
SELECT driver_id, position, status
FROM taxi_stand_queue
WHERE tenant_id=1 AND stand_id=@stand_id
ORDER BY status DESC, position ASC;
